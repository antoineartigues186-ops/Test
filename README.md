# DeFiS pipeline
DeFIS : Detection of Fauna and flora: Identification of Species.
This kmc_tools pipeline enables us to identify old DNA samples using k-mers.
Web site : https://bios4biol.pages-forge.inrae.fr/DeFiS/

## Pipeline steps
Here is an overview of DeFiS pipeline:
![alt text](https://forge.inrae.fr/bios4biol/DeFiS/-/raw/main/doc/pipeline.png)
1. Create k-mers dictionnaries for reference genomes and samples.
2. Calculate the number of k-mers occurences.
3. Search for each sample, all intersections with reference genome.
4. Calculate the number of k-mers occurences for intersection.
5. Calculate ratio, Jaccard similarity index and Jaccard distance for dissimilarity.
6. Generate graphics in an HTML report: distribution of k-mers by chromosomes, distribution of k-mers occurences by species for each sample. Graphs are generated by a python script.

## Tools required

⋅⋅⋅⋅* fastp :

A tool designed to provide fast all-in-one preprocessing for FastQ files.
Site: https://github.com/OpenGene/fastp
LICENSE: MIT

⋅⋅⋅⋅* KMC tools:

Site: https://github.com/refresh-bio/KMC
LICENSE: GPL-v3

⋅⋅⋅⋅* datamash :

GNU datamash is a command-line program which performs basic numeric, textual and statistical operations on input textual data files.
Site: https://www.gnu.org/software/datamash/
LICENSE: GPL-v3

## How to use ?
We could run DeFiS pipeline on a sample of Atlantic salmon DNA sequencing data, downloaded from NCBI public databases:
Salmo salar sample SRR23637457 : https://trace.ncbi.nlm.nih.gov/Traces/?run=SRR23637457
Use SRA Toolkit to download runs locally:

```bash
1/ Connect to Genobioinfo cluster:
$ ssh -XY login@genobioinfo.toulouse.inrae.fr
2/ Connect to a compute node:
$ srun --mem=20G --pty bash
3/ Load the sra toolkit module:
$ module load bioinfo/SRA-Toolkit/3.0.2
4/ Recovering FASTQs from your sample:
$ fastq-dump --split-files  SRR23637457
```

Downloading these files,SRR23637457_1.fastq and SRR23637457_2.fastq, may take some time. Therefore, they are also available in the data/ directory of this repository.

Our aim is to compare the k-mers of this sample with 3 reference genomes (Salmo salar, Salmo trutta and Bos Taurus). Thanks to this method, we'll be able to determine whether the sample DNA is closer to the DNA of the Salmo salar, Salmo trutta or Bos Taurus. Reference genomes dowloaded from Ensembl. We could work with downsampling fastq and only on chromosome 1 of each reference to speed up our treatments:

```bash
$ head -n 40000 SRR23637457_1.fastq > light_SRR23637457_1.fastq
$ head -n 40000 SRR23637457_2.fastq > light_SRR23637457_2.fastq
$ wget https://ftp.ensembl.org/pub/release-110/fasta/salmo_salar/dna/Salmo_salar.Ssal_v3.1.dna.primary_assembly.1.fa.gz
$ wget https://ftp.ensembl.org/pub/release-110/fasta/salmo_trutta/dna/Salmo_trutta.fSalTru1.1.dna.primary_assembly.1.fa.gz
$ wget https://ftp.ensembl.org/pub/release-109/fasta/bos_taurus/dna/Bos_taurus.ARS-UCD1.2.dna.primary_assembly.1.fa.gz
```

Warnig: All relevant files are available in the data/ directory of this repository. This includes both the original resources and all intermediate and output files generated during the processing example. Genome files are too large to be stored in the data/ directory. Moreover, they are already archived in Ensembl and can be downloaded quickly using wget command.


Warnig: Important warning if you run jobs on Genobioinfo cluster : Genobioinfo servers are NOT intended to run data processing operations, but only to submit jobs to the computing cluster. To do this, use the "sbatch" (script submission) or "srun" (interactive) commands.


Fastp sample cleaning
Fastp performs :

First, fastp trims adapter sequences from both reads using the provided sequences TTCGCAA and CAGTACT, in our example. Adapter trimming remove artificial sequences added during library preparation.
Then, fastp filters ut short reads (<25 bases). Length filtering ensures that only informative reads are retained, improving mapping and downstream results.

Here is an example of command line:

$ fastp -l 25 --adapter_sequence TTCGCAA --adapter_sequence_r2 CAGTACT -o light_cleaned_SRR23637457.1.fastq -O light_cleaned_SRR23637457.2.fastq -i light_SRR23637457_1.fastq -I light_SRR23637457_2.fastq


Explanation of each parameter and option:

-i light_SRR23637457_1.fastq         :	Input file for read 1 (forward reads) in paired-end sequencing.
-I light_SRR23637457_2.fastq         :	Input file for read 2 (reverse reads) in paired-end sequencing.
-o light_cleaned_SRR23637457.1.fastq :	Output file for cleaned read 1.
-O light_cleaned_SRR23637457.2.fastq :	Output file for cleaned read 2.
-l 25 	Minimum read length           : reads shorter than 25 bases will be discarded after trimming.
--adapter_sequence TTCGCAA           :	Specifies the adapter sequence to trim from read 1.
--adapter_sequence_r2 CAGTACT        :	Specifies the adapter sequence to trim from read 2.

Command lines on Genobioinfo cluster:

$ srun --mem=50G --pty bash
$ module load bioinfo/fastp/0.23.2
$ fastp -l 25 --adapter_sequence TTCGCAA --adapter_sequence_r2 CAGTACT -o light_cleaned_SRR23637457.1.fastq -O light_cleaned_SRR23637457.2.fastq -i light_SRR23637457_1.fastq -I light_SRR23637457_2.fastq
...
Filtering result:
reads passed filter: 19410
reads failed due to low quality: 542
reads failed due to too many N: 0
reads failed due to too short: 48
reads with adapter trimmed: 1894
bases trimmed due to adapters: 127095

Duplication rate: 2.42%

Insert size peak (evaluated by paired-end reads): 269

JSON report: fastp.json
HTML report: fastp.html

$ fastp -l 25 --adapter_sequence TTCGCAA --adapter_sequence_r2 CAGTACT -o light_cleaned_SRR23637457_1.fastq -O light_cleaned_SRR23637457_2.fastq -i light_SRR23637457_1.fastq -I light_SRR23637457_2.fastq



Create k-mers dictionnaries for reference genomes and each sample

For sample SRR23637457
For ancient DNA, reads 1 (R1 file) are of better quality than reads 2. We therefore choose to work on reads 1 files.

mkdir tmp_light_SRR23637457/ ; kmc -v -k21 -m60 -t8 -ci5 light_cleaned_SRR23637457_1.fastq  light_SRR23637457.k21  tmp_light_SRR23637457/;


On Genobioinfo cluster:

$ module load bioinfo/KMC/3.2.2
$ mkdir tmp_light_SRR23637457/ ; kmc -v -k21 -m60 -t8 -ci5 light_cleaned_SRR23637457_1.fastq  light_SRR23637457.k21  tmp_light_SRR23637457/ ;
$ rm -r tmp_light_SRR23637457
**

********** Used parameters for Stage 1 : **********
No. of input files           : 1
Output file name             : 
No. of working directories   : 1
Input format                 : FASTQ
Output format                : KMC

k-mer length                 : 21
Max. k-mer length            : 256
Signature length             : 9
Both strands                 : true
RAM only mode                : false

******* Stage 1 configuration: *******

No. of bins                  : 512
Bin part size                : 65536
Input buffer size            : 25165824

No. of readers               : 1
No. of splitters             : 7

Max. mem. size               : 60000MB
Max. mem. per storer         : 42419MB
Max. mem. for single package :   165MB

Max. mem. for PMM (bin parts): 56559MB
Max. mem. for PMM (FASTQ)    :  2624MB
Max. mem. for PMM (reads)    :     7MB
Max. mem. for PMM (b. reader):   805MB

Stage 1: 100%

********** Used parameters for Stage 2 : **********
Min. count threshold         : 5
Max. count threshold         : 1000000000
Max. counter value           : 255

******* Stage 2 configuration: *******
No. of threads               : 8

Max. mem. for 2nd stage      :    16MB

Stage 2: 100%
1st stage: 0.238336s
2nd stage: 1.55421s
Total    : 1.79255s
Tmp size : 1MB

Stats:
   No. of k-mers below min. threshold :       945492
   No. of k-mers above max. threshold :            0
   No. of unique k-mers               :       957657
   No. of unique counted k-mers       :        12165
   Total no. of k-mers                :      1202918
   Total no. of reads                 :         9705
   Total no. of super-k-mers          :       178092


Output files are compressed:

light_SRR23637457.k21.kmc_suf
light_SRR23637457.k21.kmc_pre



For reference genomes

$ mkdir tmp_chr1_Salmo_salar/;  kmc -v -k21 -m60 -t8 -ci5 -fm Salmo_salar.Ssal_v3.1.dna.primary_assembly.1.fa.gz    chr1_Salmo_salar.k21   tmp_chr1_Salmo_salar/ ;
$ mkdir tmp_chr1_Salmo_trutta/; kmc -v -k21 -m60 -t8 -ci5 -fm Salmo_trutta.fSalTru1.1.dna.primary_assembly.1.fa.gz  chr1_Salmo_trutta.k21  tmp_chr1_Salmo_trutta/ ;
$ mkdir tmp_chr1_Bos_taurus/;   kmc -v -k21 -m60 -t8 -ci5 -fm Bos_taurus.ARS-UCD1.2.dna.primary_assembly.1.fa.gz    chr1_Bos_taurus.k21  tmp_chr1_Bos_taurus/ ;


Option choosen:

-v            : Enable verbose mode (shows some information)(default: false).
-k   : The k-mer size required.
-m   : Sets the maximum amount of RAM (in Go) that KMC is allowed to use during KMC processing.
-t     : Total number of threads (default: no. of CPU cores).
-ci  : Exclude k-mers occurring less than  times.
-fm           : Multi sequences fasta.

On Genobioinfo cluster:

$ module purge
$ module load bioinfo/KMC/3.2.2
$ module load bioinfo/Jellyfish/2.3.0
$ mkdir tmp_chr1_Salmo_salar/;  kmc -v -k21 -m60 -t8 -ci5 -fm Salmo_salar.Ssal_v3.1.dna.primary_assembly.1.fa.gz    chr1_Salmo_salar.k21   tmp_chr1_Salmo_salar/ ;
$ mkdir tmp_chr1_Salmo_trutta/; kmc -v -k21 -m60 -t8 -ci5 -fm Salmo_trutta.fSalTru1.1.dna.primary_assembly.1.fa.gz  chr1_Salmo_trutta.k21  tmp_chr1_Salmo_trutta/ ;

#### Calculate the number of k-mers occurences

```diff
$ kmc_tools transform  light_SRR23637457.k21 dump light_SRR23637457.dump;
$ in1: 100% 



Search for each sample, all intersections with reference genome.

$ kmc_tools simple chr1_Salmo_salar.k21  light_SRR23637457.k21  intersect chr1_Salmo_salar_INTERSECT_light_SRR23637457;
in1: 99% in2: 100%
$ kmc_tools simple chr1_Salmo_trutta.k21 light_SRR23637457.k21  intersect chr1_Salmo_trutta_INTERSECT_light_SRR23637457;
in1: 99% in2: 100%
$ kmc_tools simple chr1_Bos_taurus.k21   light_SRR23637457.k21  intersect chr1_Bos_taurus_INTERSECT_light_SRR23637457;


Output files generated for each intersection:
chr1_Salmo_salar_INTERSECT_light_SRR23637457.kmc_pre
chr1_Salmo_salar_INTERSECT_light_SRR23637457.kmc_suf

Dump post intersection

$ kmc_tools transform  chr1_Salmo_trutta_INTERSECT_light_SRR23637457  dump  chr1_Salmo_salar_INTERSECT_light_SRR23637457.dump;
$ in1: 100% 
$ kmc_tools transform  chr1_Salmo_trutta_INTERSECT_light_SRR23637457  dump  chr1_Salmo_trutta_INTERSECT_light_SRR23637457.dump;
$ in1: 100%
$ kmc_tools transform  chr1_Bos_taurus_INTERSECT_light_SRR23637457    dump  chr1_Bos_taurus_INTERSECT_light_SRR23637457.dump;



Calculate the number of k-mers occurences for intersection

datamash sum 2 <   chr1_Salmo_salar_INTERSECT_light_SRR23637457.dump  > chr1_Salmo_salar_INTERSECT_light_SRR23637457.sum
datamash sum 2 <   chr1_Salmo_trutta_INTERSECT_light_SRR23637457.dump > chr1_Salmo_trutta_INTERSECT_light_SRR23637457.sum



Calculate ratio:
Ratios are calculated using the following python script : scripts/calculate_ratio.py
Input and output files description and examples:

$ more refs #Informations separated by tabulations
espece1	12474399
espece2	12475555
$ more sample1.sum 
30940654
$ more sample1_intesect_Ref1.sum
2447316
$ more table.csv 
Samples,Intersect_Specie,Nb_kmers_Intersect,Nb_kmers_Sample,Nb_kmers_Ref,Ratios,JS,Dj
sample1,espece1,2447316,30940654,12474399,0.079097099886770331358,0.056370217951824220968,0.94362978204817577903
sample2,espece1,2056015,31483300,12474399,0.065304939444086229842,0.046772580157118779124,0.95322741984288122088
sample3,espece2,2076022,32484400,12475555,0.063908275972466784056,0.046174912764036351905,0.95382508723596364810


To run this script:

$ module load devel/python/Python-3.12.4

$ python3 calculate_ratios.py \
  -s sample1.sum sample2.sum sample3.sum \
  -i sample1_intesect_Ref1.sum sample2_intesect_Ref1.sum sample3_intesect_Ref2.sum \
  --refs refs \
  -o table.csv \
  --samplenames sample1 sample2 sample3 \
  --speciesnames espece1 espece1 espece2


For each sample, we computed the proportion of k-mers shared with a given reference species. The ratio corresponds to the fraction of shared k-mers relative to the total number of k-mers in the sample:
Ratio = Intersecting k-mers / Total k-mers in the sample
To assess similarity between the sample and the reference, we used the Jaccard similarity index (JS), defined as:
JS = Intersecting k-mers / (k-mers in sample + k-mers in reference)
The Jaccard distance (Dj), which quantifies dissimilarity, was then calculated as:
Dj = 1 − JS
These metrics provide a normalized framework to compare k-mer overlap across samples and references, independently of sequencing depth or genome size.

Inputs and outputs files description

pre and suf files
These files are compressed.

dump files
These files are in text format
Example:

AAAAAAATAGATCGGAAGAGC	6
AAAAAACAACAACACAGAGTT	5
AAAAAAGATCGGAAGAGCGTC	5
AAAAAATAGATCGGAAGAGCA	10
AAAAAATCATGTTAAACACTA	8
AAAAAATGGTACTTACAGAGT	10
AAAAACAACAACACAGAGTTA	18






Column
Fields
Type
Description




1
k-mers
String
21 nucleotides if k21 option choosen.


2
number
Int
Number of occurence for each k-mer.



Table: dump file description.

occurences files
These files contain only a number corresponding to the number of occurrences of common k-mers between the sample and the reference.

sum files
These files contain 1 value from the sum of the dump file

Inputs files list and description
Imput the differents files sum from samples and Intesect of samples and species you got from the pipeline.
put them in the python script.

Some results
Example 1: Good identification
 
There are good ratialsthere are good ratials. The species identified with the highest ratios are S.tratuta and S.salar, which are very close genetically, which explains their high ratios. However, both the two reads 1 and 2 strands can be identified as S.tratuta (highest ratio).
Example 2: Bad identification of genetically close species
 
Ratios are very low (>0.06) and identification (by highest ratials) is not the same between reads 1 and 2.
Example 3: Bad identification due to contamination
 
Ratios are very low (>0.030) and contamination (human, mouse and otter) is observed as the first identification.

Contributing
To contribute to this project, please see the  file.
